## Using gdb
启用远程GDB这个我还是第一次用，找了篇博客解决了问题：[GDB远程连接](https://blog.csdn.net/qq_45698833/article/details/120314168)，主要还是对GDB指令不熟。
同时，修改了下``Makefile``中的内容，方便我使用：
```shell
# 新增对于gdb的脚本，教程链接：https://blog.csdn.net/qq_45698833/article/details/120314168
# target remote localhost:26000
# 在相同的xv6文件夹下riscv64-unknown-elf-gdb 再加上要调试的文件名（比如kernel/kernel或者user/_sleep）
# 也可以进入gdb后再输入file user/_[execname]加载可执行文件。
gdb:
	riscv64-unknown-elf-gdb
```

## 用户态是如何进行系统调用的？
### usys.pl的作用
这是一个``perl``脚本：
```perl
#!/usr/bin/perl -w

# Generate usys.S, the stubs for syscalls.
# 这是一个prel脚本，用于自动化生成usys.S

print "# generated by usys.pl - do not edit\n";

print "#include \"kernel/syscall.h\"\n";

sub entry {
    my $name = shift;
    print ".global $name\n";
    print "${name}:\n";
    print " li a7, SYS_${name}\n"; # a7是RISCV中，专门用于存放系统调用号的寄存器
    print " ecall\n";
    print " ret\n";
}
	
entry("fork");
entry("exit");
entry("wait");
entry("pipe");
entry("read");
entry("write");
entry("close");
entry("kill");
entry("exec");
entry("open");
entry("mknod");
entry("unlink");
entry("fstat");
entry("link");
entry("mkdir");
entry("chdir");
entry("dup");
entry("getpid");
entry("sbrk");
entry("sleep");
entry("uptime");
entry("trace");

```
该脚本语言主要是用于==字符串处理==，其实这里就是，根据模板去生成ASM代码，这样能省很多事情。

从这段汇编代码中其实还是能够获得一些信息的：在进入用户态进入syscall之后，==会将系统调用号放在a7寄存器中， 然后使用ecall指令，进入切换到内核态==。具体的可以看看RISC-V的关于``ecall``指令的文档。

### 用户态系统使用的调用名称为何和内核态的声明不一样？
注意到``user``中的系统调用都如``fork``、 ``exit``，而``kernel``中定义的时候却是如``sys_fork``，那么，在使用系统调用的时候是如何正常索引到想要的代码的呢？

这个问题的答案实际上就在上述脚本生成的汇编代码中，这里就用``fork``来举例吧：
```asm
.global fork
fork:
	 li a7, SYS_fork
	 ecall\n";
	 ret
```
它声明了一个**全局标签**``fork``，当跳转到该标签的时候，就会跳转到对应的syscall，这也是为什么用户态中，syscall都没有前面的``SYS``字样，而在内核态的时候却出现的的原因。

在``kernel/syscall.h``中，能够找到所有的系统调用所对应的**系统调用号**：
```c
// System call numbers
#define SYS_fork    1
#define SYS_exit    2
#define SYS_wait    3
#define SYS_pipe    4
#define SYS_read    5
#define SYS_kill    6
#define SYS_exec    7
#define SYS_fstat   8
#define SYS_chdir   9
#define SYS_dup    10
#define SYS_getpid 11
#define SYS_sbrk   12
#define SYS_sleep  13
#define SYS_uptime 14
#define SYS_open   15
#define SYS_write  16
#define SYS_mknod  17
#define SYS_unlink 18
#define SYS_link   19
#define SYS_mkdir  20
#define SYS_close  21
#define SYS_trace  22 // add
```

然后在``kernel/syscall.c``中能看到以下定义：
```c
// Prototypes for the functions that handle system calls.
extern uint64 sys_fork(void);
extern uint64 sys_exit(void);
extern uint64 sys_wait(void);
extern uint64 sys_pipe(void);
extern uint64 sys_read(void);
extern uint64 sys_kill(void);
extern uint64 sys_exec(void);
extern uint64 sys_fstat(void);
extern uint64 sys_chdir(void);
extern uint64 sys_dup(void);
extern uint64 sys_getpid(void);
extern uint64 sys_sbrk(void);
extern uint64 sys_sleep(void);
extern uint64 sys_uptime(void);
extern uint64 sys_open(void);
extern uint64 sys_write(void);
extern uint64 sys_mknod(void);
extern uint64 sys_unlink(void);
extern uint64 sys_link(void);
extern uint64 sys_mkdir(void);
extern uint64 sys_close(void);
extern uint64 sys_trace(void); // add

static uint64 (*syscalls[])(void) = {
[SYS_fork]    sys_fork,
[SYS_exit]    sys_exit,
[SYS_wait]    sys_wait,
[SYS_pipe]    sys_pipe,
[SYS_read]    sys_read,
[SYS_kill]    sys_kill,
[SYS_exec]    sys_exec,
[SYS_fstat]   sys_fstat,
[SYS_chdir]   sys_chdir,
[SYS_dup]     sys_dup,
[SYS_getpid]  sys_getpid,
[SYS_sbrk]    sys_sbrk,
[SYS_sleep]   sys_sleep,
[SYS_uptime]  sys_uptime,
[SYS_open]    sys_open,
[SYS_write]   sys_write,
[SYS_mknod]   sys_mknod,
[SYS_unlink]  sys_unlink,
[SYS_link]    sys_link,
[SYS_mkdir]   sys_mkdir,
[SYS_close]   sys_close,
[SYS_trace]   sys_trace // add
};
```
这段代码分为两部分：
1. **函数原型**（外部函数声明），这部分会在链接的时候找到所有对应函数的实现，获得相应的函数指针
2. 一个存储**函数指针**的数组（syscalls），其存储的所有函数的返回值皆为``int``类型，并且无函数传参（void）

这样，就将系统调用号和中断处理函数关联起来了。

### syscall函数在哪进行调用？
刚刚通过查看``user``文件夹中的代码，大致知道了用户态中的程序是如何进行系统调用的：==当在用户态的程序中使用``syscall``之后，会跳转到``usys.S``（由usys.pl自动化生成的汇编代码中），通过``ecall``指令进入内核态==。

在``kernel/syscall.c``中，我们能找到一个函数：``syscall``：
```c

void
syscall(void)
{
  int num;
  struct proc *p = myproc();

  num = p->trapframe->a7; // 获取要执行的系统调用号

  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
    // Use num to lookup the system call function for num, call it,
    // and store its return value in p->trapframe->a0
    p->trapframe->a0 = syscalls[num](); // 实际执行系统调用，然后将系统调用的返回值存储在a0中
  } else {
    printf("%d %s: unknown sys call %d\n",
            p->pid, p->name, num);
    p->trapframe->a0 = -1;
  }
}
```
不难看出来：==在陷入内核态之后，函数``syscall``才是实际执行系统调用的部分==。

但是这里由引出了新的问题：
- 从汇编代码中仅仅得到两个信息：
	1. ``a7``寄存器用于保存系统调用号
	2. ``ecall``指令完成用户态和内核态之间的切换

那么，``ecall``指令跳转去哪？它具体是如何进入内核态的？

因为``syscall``是``tarp``，很自然的就会想到去查看``trap.c``中的内容，但是单看它似乎并没有得到任何有用的信息，于是猜想：ecall并且没有想象中的这么简单。

#### ecall指令
``ecall``只做两件事：
1. 触发系统调用
2. 进行用户态和内核态的切换

那么，它是如何触发系统调用的？这就要提到**stvec寄存器**了。
##### stvec寄存器
``stvec``寄存器在``trap``中起到了关键的作用：<font color="red">它是专门用于陷阱和中断处理的的寄存器，其中存储的是陷阱处理程序的地址</font>。

``stvec``具有两种工作模式：**直接模式**和**向量模式**。直接模式就是说，该寄存器中存储的地址就是特定的中断处理程序的地址；而向量模式说明该寄存器中存储的是一个**基地址**，加上一个偏移量才是指定的程序的地址（类似于数组）。

因此，接下来需要寻找：==``stvec``与何处被设置？==

在``trap.c``中能够看到这么一段函数：
```c
// set up to take exceptions and traps while in the kernel.
//    设置内核中处理异常和中断
void
trapinithart(void)
{
  // 设置stvec寄存器，将其设置为kernelvec的地址
  w_stvec((uint64)kernelvec);
}
```
该函数就对``stvec``寄存器进行了设置，将其设置为``kernelvec``的地址。然后**ecall**在触发的时候就会跳转到``kernelvec``，由此便成功进入到内核态了。

设置``stvec``的函数已经找到了，不难发现它是在``main.c``中被调用的：
```c
#include "types.h"
#include "param.h"
#include "memlayout.h"
#include "riscv.h"
#include "defs.h"

volatile static int started = 0;

// start() jumps here in supervisor mode on all CPUs.
void
main()
{
  if(cpuid() == 0){
    consoleinit();
    printfinit();
    printf("\n");
    printf("xv6 kernel is booting\n");
    printf("\n");
    kinit();         // physical page allocator
    kvminit();       // create kernel page table
    kvminithart();   // turn on paging
    procinit();      // process table
    trapinit();      // trap vectors
    trapinithart();  // install kernel trap vector
    plicinit();      // set up interrupt controller
    plicinithart();  // ask PLIC for device interrupts
    binit();         // buffer cache
    iinit();         // inode table
    fileinit();      // file table
    virtio_disk_init(); // emulated hard disk
    userinit();      // first user process
    __sync_synchronize();
    started = 1;
  } else {
    while(started == 0)
      ;
    __sync_synchronize();
    printf("hart %d starting\n", cpuid());
    kvminithart();    // turn on paging
    trapinithart();   // install kernel trap vector
    plicinithart();   // ask PLIC for device interrupts
  }

  scheduler();        
}

```
``main.c``是==操作系统内核启动的主函数==，所以说<font color="red">中断调用程序在操作系统启动的时候就被设置了</font>。

现在，操作系统成功由用户态进入内核态，但是用户态中想调用的syscall此时还没有运行，问题还没有完全解决。

### 现在能正式运行syscall了吗？
从``trapinithart``函数中可以知道：<font color="red">trap处理函数为kernelvec</font>，对应的实现在``kernelvec.S``中，代码有点长，这里就不贴出来了，总结一下，它只做了三件事：
1. 在**内核栈**中保存寄存器的值
2. ``call kerneltrap``
3. 恢复寄存器的值，返回

于是我就接下去查看``kerneltrap``的代码，然后我就懵了：
```c
void 
kerneltrap()
{
  int which_dev = 0;
  uint64 sepc = r_sepc(); // sepc寄存器，用于记录异常发生时的程序计数器（PC）值
                          // 使得中断处理程序执行完之后，能够恢复程序的运行状态
  uint64 sstatus = r_sstatus(); // 获取sstatus寄存器的值，该寄存器用于控制和保存处理器状态
  uint64 scause = r_scause(); // 获取scause寄存器的值，该寄存器用于保存导致异常或中断的原因
  
  if((sstatus & SSTATUS_SPP) == 0)  // 上一条指令的运行模式是用户模式，这说明权限错了
                                    // SSTATUS_SPP的定义中有写
    panic("kerneltrap: not from supervisor mode");
  if(intr_get() != 0) // syscall的时候不允许设备中断（我不是很理解为什么要这么做）
    panic("kerneltrap: interrupts enabled");

  if((which_dev = devintr()) == 0){
    printf("scause %p\n", scause);
    printf("sepc=%p stval=%p\n", r_sepc(), r_stval());
    panic("kerneltrap");
  }

  // give up the CPU if this is a timer interrupt.
  if(which_dev == 2 && myproc() != 0 && myproc()->state == RUNNING)
    yield();

  // the yield() may have caused some traps to occur,
  // so restore trap registers for use by kernelvec.S's sepc instruction.
  w_sepc(sepc);
  w_sstatus(sstatus);
}
```
这个函数中我没有找到任何和syscall有关的部分，所以我的思路出现了点问题。

### 重整旗鼓
在Using GDB中，我们能看到syscall是正确进入``usertrap``的，因此代码肯定没错，错的是我。

继续查看``kernel/trap.c``，不过这次换个方向，从``usertrap``入手，看看什么时候会将``stvec``设置为``uservec``：
```c
void
usertrapret(void)
{
...

  // send syscalls, interrupts, and exceptions to uservec in trampoline.S
  uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);  // 计算当前进程中，userver的地址
                                                                    // TRAMPOLINE是当前进程的内核栈的地址（虚拟地址）
                                                                    // uservec - trampoline是在计算偏移量（具体可看trampoline.S）
  w_stvec(trampoline_uservec); // 将stvec设置为uservec

  // set up trapframe values that uservec will need when
  // the process next traps into the kernel.
  p->trapframe->kernel_satp = r_satp();         // kernel page table
  p->trapframe->kernel_sp = p->kstack + PGSIZE; // process's kernel stack
  p->trapframe->kernel_trap = (uint64)usertrap;
  p->trapframe->kernel_hartid = r_tp();         // hartid for cpuid()

...
}
```
在该函数中，完成了==对进程的``trapframe``的设置，和对寄存器状态和恢复==，除此之外，再也找不到对``usertrap``和``uservec``的设置了。

那么``usertrapret``在哪被调用？
1. ``usertrap``，但是首次调用肯定不是这里，因为我现在正愁进不到``usertrap``中
2. 在``kernel/proc.c``的``forkret``中

继续追查``forkret``，可以发现它在``allocproc``中被设置为``ra``寄存器的值（==``ra``寄存器用于保存返回地址，在一个函数调用结束后，会读取``ra``寄存器所存储的函数地址，然后执行==）：
```c
static struct proc*
allocproc(void)
{
...

  // Set up new context to start executing at forkret,
  // which returns to user space.
  // 设置一个从forket开始的新上下文
  // 这将会返回到用户空间
  memset(&p->context, 0, sizeof(p->context));
  p->context.ra = (uint64)forkret;  // ra存储的是返回地址（return address）
                                    // 在alloproc执行完之后，控制流将会回到forket
  p->context.sp = p->kstack + PGSIZE;

...
}
```

在``main.c``中，曾使用``userinit``创建了操作系统的第一个进程，而该``init``进程的创建就是通过``allocproc``！

<font color="sky-blue"><b>现在就算是解开syscall的谜题了！！！</b></font>

### 总结
在操作系统内核启动的时候，创建了系统中的第一个进程：<font color="red"><b>initcode</b></font>；在创建该进程的时候使用的函数``allocproc``将其上下文中的``ra``寄存器设置为``forkret``，当进行**上下文切换**之后，==回到用户空间的进程将会运行``forkret``部分的代码==，从而进入``usertrapret``中，由此完成对用户态中断处理函数的设置。

现在就知道syscall是如何进入内核态的了。

在``userinit``中，完成了第一个进程的创建：``initcode``，该进程在被调度后执行``user/init.S``，这就是操作系统的第一个进程：init的由来。
```c
// exec("/init")的字节码
// a user program that calls exec("/init")
// assembled from ../user/initcode.S
// od -t xC ../user/initcode
uchar initcode[] = {
  0x17, 0x05, 0x00, 0x00, 0x13, 0x05, 0x45, 0x02,
  0x97, 0x05, 0x00, 0x00, 0x93, 0x85, 0x35, 0x02,
  0x93, 0x08, 0x70, 0x00, 0x73, 0x00, 0x00, 0x00,
  0x93, 0x08, 0x20, 0x00, 0x73, 0x00, 0x00, 0x00,
  0xef, 0xf0, 0x9f, 0xff, 0x2f, 0x69, 0x6e, 0x69,
  0x74, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00
};

// Set up first user process.
// 注册第一个进程
void
userinit(void)
{
  struct proc *p;

  p = allocproc();
  initproc = p;
  
  // allocate one user page and copy initcode's instructions
  // and data into it.
  uvmfirst(p->pagetable, initcode, sizeof(initcode));
  p->sz = PGSIZE;

  // prepare for the very first "return" from kernel to user.
  p->trapframe->epc = 0;      // user program counter
							 // 设置pc为0
							 // 刚刚设置了0处是initcode
  p->trapframe->sp = PGSIZE;  // user stack pointer

  safestrcpy(p->name, "initcode", sizeof(p->name));
  p->cwd = namei("/");

  p->state = RUNNABLE;

  release(&p->lock);
}
```
