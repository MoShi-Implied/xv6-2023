usertrap () at kernel/trap.c:67

放置的是系统调用编号SYS_exec
能看到a7中存储的是个地址：0x87f74000
使用print $a7看到值为15，但是我不知道这个数值的作用是什么

我看不懂，但是我给GPT分析了，他说：
    CPU当前运行的模式是“用户模式”，而在此之前它的模式是“超级模式”

出错的指令：
    // num = p->trapframe->a7;
    num = *(int *) 0;
    800020a2:	00002683          	lw	a3,0(zero) # 0 <_entry-0x80000000>
可以看出，num对应的是a3寄存器

在panic之前能看到如下内容：
    scause 0x000000000000000d
扔给AI分析：
    scause 寄存器的值为 0x000000000000000d (也就是 13)
    表明当前的 trap 是由 异常 引起的
    并且具体原因是 指令页故障（Instruction Page Fault）。 
替换的指令为：   num = *(int *) 0;
    首先这段指令我就没玩明白，说明我对C语言中指针的理解是错误的，现在对这条语句进行一个简单的解释：
        1. (int*)0 表示将0转换为一个指针，放在C语言中就是NULL
        2. 对NULL进行解引用操作，也就是*0，表示对地址为0的内存进行一个访问
        3. 出现panic报错
这就说明：地址0并没有映射到内存地址空间

p p->name可以看到：name = 0x800081b8 "proc"
说明刚刚出错的进程名称为proc，pid为1，具体内容如下：
    (gdb) print *p
    $2 = {lock = {locked = 0, name = 0x800081b8 "proc", cpu = 0x0}, state = RUNNING, chan = 0x0, killed = 0, xstate = 0, pid = 1, 
    parent = 0x0, kstack = 274877894656, sz = 16384, pagetable = 0x87f6c000, trapframe = 0x87f74000, context = {ra = 2147489044, 
    sp = 274877897312, s0 = 274877897360, s1 = 2147519824, s2 = 2147518752, s3 = 1, s4 = 3, s5 = 2147588592, s6 = 0, s7 = 360, 
    s8 = 18446744073709551615, s9 = 1024, s10 = 2, s11 = 56}, ofile = {0x0 <repeats 16 times>}, cwd = 0x80016e60 <itable+24>, 
    name = "init\000\000de\000\000\000\000\000\000\000"}
我没看出来是哪个二进制程序导致的bug，但是根据bt，应该是trap