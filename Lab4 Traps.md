## RISC-V assembly
这个其实我没有认真做，因为这个riscv汇编和x86汇编相差确实有点大，而且我这段时间不知道为什么，没有什么心情学下去，因此答案是GPT+博客得到的结果（不如看大佬的博客）：
```txt
（因为我实在是不懂riscv汇编，这部分其实都是AI写的）

1. 在寄存器a2中拥有13, a1也是函数参数
    a0-a7都用于存储函数调用参数

2. 对函数f的调用在printf中，但是在main中并没有实际调用（asm看出来的）
    这说明进行了内联优化
    对函数g也没有进行调用，也被内联优化了

3. 000000000000065a 是printf的地址

4. 	unsigned int i = 0x00646c72;
	printf("H%x Wo%s", 57616, &i);

5. 在跳转到printf之后，寄存器ra的值为： 4501
```

## Backtrace
这个lab对我来说的主要难点就是==我没有很好的理解题目意思==，做这个的时候我心浮气躁，于是参考了大佬的博客，这里就说说我做完后的收获吧。

题目中其实给了很多很多的提示，该题的最终目的是：==编写函数``backtrace``，使用帧指针在堆栈中向上移动，并在每个堆栈帧中打印保存的返回地址==。
首先，提示了我们能通过使用新添加的函数得到当前的**帧指针**，该帧指针是在栈顶：
```c
// kernel/riscv.h

static inline uint64
r_fp()
{
  uint64 x;
  asm volatile("mv %0, s0" : "=r" (x) );
  return x;
}
```
同时，最关键的一点：
> 您将 backtrace() 需要一种方法来识别它已经看到了最后一个堆栈帧，并且应该停止。一个有用的事实是，为每个 kernel stack 分配的内存由一个页面对齐的页面组成，因此给定堆栈的所有堆栈帧都位于同一页面上。可以使用 PGROUNDDOWN(fp) （请参阅 kernel/riscv.h ） 来标识框架指针引用的页面。

对于这段话其实我是有疑惑的：==它提到所有的堆栈帧都位于同一个页面上==。我不明白为什么这里又变成了内核栈了，要理解这个，<font color="red"><b>或许我需要将整个lab做完之后才能回答吧，现在的我对于进程的运行和启动知之甚少</b></font>。

根据[这篇文章](https://pdos.csail.mit.edu/6.1810/2023/lec/l-riscv.txt)，可以了解到``riscv``中的栈结构是什么样的，这对我们做lab很有帮助。

在``kernel/printf.c``中添加函数（前提是已经根据lab提示添加了函数原型）：
```c
// kernel/printf.c

void backtrace() {
  uint64 fp = r_fp(); // 栈顶的堆栈帧的地址

  while(fp < PGROUNDUP(fp)) { // 因为栈是向上生长的
    uint64 ra = *((uint64*)(fp - 8));
    printf("%p\n", ra);

    fp = *((uint64*)(fp - 16));
  }
}
```
这段代码在我一开始做的时候其实还是有点疑惑的，是关于while循环的条件，一开始我写的是：
```c
while(fp >= PGROUNDDOWN(fp))
```
但是这样导致了系统崩溃：
```txt
$ bttest
0x00000000800021d6
0x00000000800020cc
0x0000000080001dca
0x0000000000000012
scause 0x000000000000000d
sepc=0x0000000080006028 stval=0x0000000000003fc8
panic: kerneltrap

```
根据这几个报错，发给GPT，发现是出现了**页错误**，有以下几种情况：
1. 页面未映射: 该内存地址没有有效的页面映射，即没有相应的物理内存页面被分配给该虚拟地址。
2. 权限不足: 当前的特权级别或权限配置不允许读取该内存地址。
3. 页面表损坏: 系统内存管理单元 (MMU) 的页面表可能存在错误或损坏。

但是能看到，前三个地址是正常打印的，这就说明问题出在循环上。

在提示中，已经知道了==所有的堆栈帧都在同一页中==，而又能知道：我们是将当前堆栈帧的位置**下移**，从而找到返回地址和先前的堆栈帧，因此，问题一定在这个移动这里。
根据栈帧中的布局，并且==内核栈是页对齐的==，因此``fp``一定是小于该页的最高地址的（因为是栈，若是等于，说明这到了栈底），因此边得到正确条件应该是：
```c
while(fp < PGROUNDUP(fp))
```

## alarm
这个任务实际上分了2个部分，循循渐进。

### test0
首先，根据提示，需要在``kernel/proc.h``更改``proc``的结构，这里我增加了三个变量：
```c
uint64 ticks;  // 指定的时钟周期数
void (*fn)();  // 需要执行的函数
uint64 passed; // 距离上次调用fn所距离的时钟周期数
```
并且在创建进程的时候对这三个进程进行初始化，释放进程的时候再初始化一遍（``allocproc``和``freeproc``都添加以下代码）：
```c
p->fn = 0; // 不知道这个一开始初始化为什么好
p->ticks = 0;
p->passed = 0;
```
然后按照添加syscall的步骤先将需要添加的syscall原型先添加好，这一步应该已经很熟悉了，我就跳过了。

在``sysproc.c``添加对这两个系统调用的实现（我参数准备和实现放在一起了，没有分为两个函数，但是若是按照xv6的编写标准来说，``sys_sigalarm``这个函数仅仅进行参数准备，而不进行其它的操作，其它操作应该现在``kernel/defs.h``中先添加函数原型之后，于``kernel/proc.c``中实现，我这里算是偷了个小懒）。
```c
// kernel/sysproc.c

uint64 sys_sigalarm() {
  int n;
  uint64 fn; // 因为是函数调用，因此这里应该是函数地址
  
  argint(0, &n);
  argaddr(1, &fn); // fn中存储的是这个函数的地址

  // 设置参数
  struct proc* p = myproc();
  p->fn = (void(*)()) fn;
  p->ticks = n;
  p->passed = 0; // 重置计数器
  
  return 0;
}

uint64 sys_sigreturn() {
  return 0;
}
```

这里没遇到什么大问题，就是==对于函数指针的表达和强制转换这块还是问了GPT，对于函数指针还是有点小问题吧==。

在``kernel/trap.c``中的``usertrap``中添加对中断处理的核心逻辑：
```c
// 这说明是正常的中断
else if((which_dev = devintr()) != 0){
		// ok
		// 如果这个是来自定时器的中断
		if(which_dev == 2 && p->ticks != 0) {
			p->passed++;
		
		if(p->passed == p->ticks) {
			p->passed = 0;
			// p->fn(); // 执行指定的函数
			p->trapframe->epc = (uint64)p->fn;
		}
	}
}
```
这部分的逻辑还是很简单的，只要理解了题意想必还是很好理解的，但是我在这里还是犯了错：一开始我是在该段函数中直接对需要执行的函数进行调用，但是在执行的时候会直接发生``panic``，错误内容是因为访问了不允许访问的页面，很明显问题是在这行上，<font color="red"><b>在进入到内核空间后的，它所使用的地址用户空间传进来的地址是不一样的，而我这里相当于在内核空间使用了在用户空间才合法的地址</b></font>，因此，==执行函数这个功能只能由用户空间完成，内核空间是做不到的，唯一的办法就是更改pc指针的值，使其回到用户空间之后就执行该代码==。

#### 用户视角到内核视角
经过了``pgtable``这个lab其实我已经很清楚：用户空间所看到的地址和内核空间看到的地址其实是两码事，两个空间中看到的地址都不是物理地址，都是虚拟地址，只是说内核中的权限更高一点，能够做更多和，而在使用ecall之后，程序的执行权限转为特权级，程序的执行权回到了操作系统的手中（通过使用``stvec``寄存器中所保存的函数地址）。

<font color="red"><b>然后我现在就有疑惑了：在这个步骤中，进程空间是如何进行切换的？在什么时候，由用户进程的地址空间切换到了内核空间？</b></font>

要理解这个疑惑，还是要看程序到底是怎么由用户态进入内核态的。

在先前的lab中，已经很清楚的知道了几点：
1. 在进程创建之初，返回用户态之前，``stvec``寄存器会被设置为``uservec``这个函数的地址，当用户进程发生了``trap``的时候，就会跳转到``stvec``这个寄存器所保存的中断处理程序的地址，寄存器保存等必要的操作，==但是这个函数其实还完成了一些很关键的任务，这是我之前没有提过的，接下来再说==
2. 用户程序调用syscall其实是通过``ecall``指令，这点是在``user/usys.pl``中验证的，通过``ecall``指令，会对硬件的权限进行升级，同时``stvec``在此处发挥所用了：pc更改为该处理程序的地址

所以所有的疑惑应该都在做这个**中断处理程序**中能找到答案，查看``kernel/trampoline.S``能看到以下很关键的内容：
```asm
# install the kernel page table.
csrw satp, t1
```
这行汇编代码==完成了页表的切换==，而页表的作用就是进行地址转化，所以，<font color="red"><b>此时就是真正意义上的切换到了内核空间</b></font>。

### test1/2/3
<font color="red"><b>我怀疑是编译器优化的原因，我过不了test3，但是我的代码逻辑是正确的（我试了很多大佬的代码，都没法在我的环境中通过test3，不知道到底是哪里出现问题了）</b></font>。

在test0中，只是完成了一点：对alarm的handle的设置。这使得操作系统在回到用户态之后会执行``fn``这个函数。

在该任务中需要注意几点：
1. 若是现在正在执行一个handle（没执行完），而又来了一个新的handle，此时新来的handle不应该被执行（这是在hints中说明了的，但我一开始没有注意到，被硬控了）
2. test3是测trapframe是否已经恢复到位了（<font color="red"><b>我就是这里出现了问题，通过GDB发现，我的代码在进入``usys.S``的时候，``a0``的值就发生了改变，我怀疑这是编译器优化的问题，但是不是很确定，毕竟我能做的都做了，基本所有的故障我都排除了，但是都还是没法解决这个问题</b></font>）

首先我觉得还是需要从测试代码的逻辑下手，能看到，所有的handle中都调用了``sigreturn``，因为通过test0就能知道，想要在中断发生后执行想要的handle，只有一种办法：==更改用户的pc指针的值==，若是想完成题目的要求：==需要在handle执行完之后回到原本程序的执行位置==，只有在``sigreturn``中恢复所有的寄存器状态（任务也正是如此）：
```c
// user/alarmtest.c
void
dummy_handler()
{
  sigalarm(0, 0);
  // printf("已关闭计时器调用\n");
  sigreturn();
}
```
所以，现在的进程要添加的所有变量如下：
```c
// kernel.proc.h

uint64 ticks; // 指定的定时器周期，即多少个ticks就要执行一次handle
void (*fn)(); // 传进来的handle
uint64 passed; // 距离上一次执行handle所经过的时间

struct trapframe* alarm_tf; // 用户初始的中断帧副本
int running; // 用来标识现在有没有handle（也就是fn）正在执行的
```
自然而然的，就需要在``kernel/proc.c``中对这些变量进行初始化和释放：
```c
// kernel/proc.c

/*
	allocproc
*/
...
  p->fn = 0; // 不知道这个一开始初始化为什么好
  p->ticks = 0;
  p->passed = 0;
  p->running = 0;
...
  // 为alarm_tf分配内存
  // 由于这部分内存不会被显示访问，只是用于临时存储，因此它不需要进行映射
  if((p->alarm_tf = (struct trapframe*)kalloc()) == 0) {
    freeproc(p);
    release(&p->lock);
    return 0;
  }
...


/*
	freeporc
*/
...
  if(p->alarm_tf) 
    kfree((void*)p->alarm_tf);
  p->alarm_tf = 0;
...
  p->fn = 0;
  p->ticks = 0;
  p->passed =0;
  p->running = 0;
...
```
==我的代码中使用``kalloc``和``kfree``进行内存管理，需要手动管理``alarm_tf``的内存==（这一步很重要！千万不能忘了，我一开始忘了是因为我对指针还是有不理解之处），这是因为我的``alarm_tf``使用的是指针类型，需要手动对空间进行管理，若是这里我不使用指针而是将其更换为普通变量，就可以忽略这一步，此时在创建``proc``的时候就会为其预留足够的内存，我觉得这种方案比我使用指针是更好的，因为需要更改的地方更少，并且更好维护。

最重要的部分就是在``kernel/trap.c``中的``usertrap``中：
```c
// kernel/trap.c

// 如果这个是来自定时器的中断
if(which_dev == 2 && p->ticks != 0) {
  p->passed++;

  if(p->passed >= p->ticks && !p->running) { // 当前不能有正在执行的handle
	p->passed = 0; // 重置计时器
	// p->fn(); // 执行指定的函数(错误的)
	*(p->alarm_tf) = *(p->trapframe); // 保存用于的原始中断帧
	p->trapframe->epc = (uint64)p->fn;
  }
}
```
在此处保存用户最后的**中断帧**，然后再在``sigreturn``中恢复，就完成了该lab：
```c
// kernel/sysproc.c

uint64 sys_sigalarm() {
  int n;
  uint64 fn; // 因为是函数调用，因此这里应该是函数地址
  
  argint(0, &n);
  argaddr(1, &fn); // fn中存储的是这个函数的地址

  // 设置参数
  struct proc* p = myproc();
  p->fn = (void(*)()) fn; // 强转为函数指针
  p->ticks = n;
  p->passed = 0; // 重置计数器
  
  return 0;
}

uint64 sys_sigreturn() {
  // 恢复原始栈帧，能这么做是因为在传入的fn中调用了sigreturn
  // 若是fn中没调用该函数，那么我这么做就是错误的
  struct proc* p = myproc();

  // p->ticks = 0;  // 该函数只用于恢复运行情况，不能用于停止调用fn
                    // 若是想要停止调用fn需要在用户程序中显式地使用sigalarm(0, 0)
  p->running = 0; // 表示当前没有指定的handle了
  *(p->trapframe) = *(p->alarm_tf);

  return 0xac; // 我不知道为什么是要返回这个值，我是看到test3中是与这个值进行比较的
               // 但是这个是我最后调用的函数了，所以返回值应该只能在此处进行设置
               // 但是别的大佬的返回值都是0
               // 我怀疑是因为编译器优化导致的
               // 使我在进入内核态之前，栈帧的a0就错了
}
```